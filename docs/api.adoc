= API

This documentation lists and describes all static GraphQL types

== Common arguments

|===
|Name | Remark | Default value

|key
|Designs a content path or content ID
|

|offset
|Start index
|0

|first
|Number of content to fetch
|10

|sort
|Sorting expression
|"_score DESC"
|===

== Object Types
=== Query 

==== Fields
|===
|Name(Arguments):Type | Description

|guillotine: <<HeadlessCms>>
|Type gathering all content retrieval requests
|===

=== HeadlessCms 

Gathers all content retrieval requests. 

==== Remarks

* Most requests expect a key as argument. If the key is not specified, then the matched content will be the one corresponding to the current execution context

==== Fields

|===
|Name(Arguments):Type | Description

|get(key: ID): <<Content>>
|Fetches a content

|getChildren(
 key: ID,
 offset: Int,
 first: Int,
 sort: String
 ): [<<Content>>]
|Fetches the children of a content

|getChildrenConnection(
 key: ID,
 after: String,
 first: Int,
 sort: String
 ): <<ContentConnection>>
| Fetches the children of a content and return the result as a connection

|getPermissions(key: ID): <<Permissions>>
|Fetches the permissions on a content

|getSite: portal_Site
|Fetches the parent site of the content corresponding to the current execution context

|query(
 query: String,
 offset: Int,
 first: Int,
 sort: String,
 contentTypes: [String],
 aggregations: [<<AggregationInput>>],
 filters: [<<FilterInput>>]
 ): [<<QueryResult>>]
|Queries contents

|queryConnection(
 query: String!,
 after: String,
 first: Int,
 sort: String,
 contentTypes: [String],
 aggregations: [<<AggregationInput>>],
 filters: [<<FilterInput>>]
 ): <<QueryContentConnection>>
|Queries contents and returns the result as a connection

|getType(name: String!): <<ContentType>>
|Retrieves the properties and icon of the specified content type

|getTypes: [<<ContentType>>]
|Retrieves the list of all content types available for the current site
|===

=== Content

Interface of all contents.

==== Fields
|===
|Name(Arguments):Type | Description

|_id: ID!
|Content ID

|_name: String!
|Content name

|_path: String!
|Content path

|creator: <<PrincipalKey>>
|Content creator

|modifier: <<PrincipalKey>>
|Last content modifier

|createdTime: String
|Content creation time

|modifiedTime: String
|Last content modification time

|owner: <<PrincipalKey>>
|Content owner

|type: String
|Content type

|displayName: String
|Content display name

|hasChildren: Boolean
|true if the content has children content

|language: String
|Content language

|valid: Boolean
|true if the content is valid

|dataAsJson: JSON
|Content data

|x: [<<ExtraData>>]
|Content extra data

|pageAsJson: JSON
|Page specific information

|pageTemplate: <<Content>>
|Related page template content

|components: [<<Component>>]
|Flattened list of page components

|attachments: [<<Attachment>>]
|Content attachments

|publish: <<PublishInfo>>
|Publication information

|pageUrl(type: <<UrlType>>, params: String): String
|Util field to generate a URL pointing to the content

|site: portal_Site
|Link to the nearest site

|parent: <<Content>>
|Link to the content parent

|children(
offset: Int, 
first: Int, 
sort: String
): [<<Content>>]
|Link to the direct child contents

|childrenConnection(
after: String, 
first: Int, 
sort: String
): <<ContentConnection>>
|Connection to the direct child contents

|permissions: <<Permissions>>
|Content permissions
|===

==== Direct Known Subtypes

Direct Known Subtypes: 
portal_Site
, base_Folder
, media_Code
, media_Executable
, media_Text
, media_Vector
, media_Spreadsheet
, media_Data
, base_Structured
, base_Shortcut
, base_Media
, media_Document
, media_Video
, media_Presentation
, media_Archive
, media_Audio
, portal_PageTemplate
, media_Unknown
, portal_TemplateFolder
, media_Image
, base_Unstructured
, portal_Fragment

=== ContentConnection

To ease the pagination of relationship to a content, the type ContentConnection has been created to represent this connection.
It allows you to :

* Paginate through the list of contents.
* Ask for information about the connection itself, like totalCount or pageInfo.
* Ask for information about the edge itself, like cursor.

==== Fields

|===
|Name(Arguments):Type | Description

|totalCount: Int!
|Total number of related content

|edges: [<<ContentEdge>>]
|Edge to the related content

|pageInfo: <<PageInfo>>
|Paging information

|===

=== QueryContentConnection

image:images/v-500.svg[Since version,opts=inline]

==== Fields

|===
|Name(Arguments):Type | Description

|totalCount: Int!
|Total number of related content

|edges: [<<ContentEdge>>]
|Edge to the related content

|pageInfo: <<PageInfo>>
|Paging information

|aggregationAsJson: JSON
|Result of aggregations

|===

=== ContentEdge

==== Fields

|===
|Name(Arguments):Type | Description

|node: <<Content>>!
|Related content

|cursor: String!
|Edge cursor

|===

=== PageInfo

==== Fields

|===
|Name(Arguments):Type | Description

|startCursor: String!
|Start cursor of the pagination

|endCursor: String!
|End cursor of the pagination

|hasNext: Boolean!
|Has more related contents at end cursor

|===

=== QueryResult

image:images/v-500.svg[Since version,opts=inline]

==== Fields

|===
|Name (Arguments): Type | Description

|hits: [<<Content>>]
|Related contents

|aggregationAsJson: JSON
|Result of aggregations

|===


=== HtmlEditorResult

image:images/v-500.svg[Since version,opts=inline] Represents result of HtmlArea processing.

|===
|Name (Arguments): Type | Description

|raw: String
|HtmlEditor raw value

|markup: String
|HtmlEditor with processed value that contains replaced internal links to resources, content and translated macros. For macros without descriptors processing will be skipped

|macrosAsJson: JSON
|Represents macro details in JSON format

|macros: <<MacroDataConfigType>>
|Represents details of macros which were detected in the `HtmlArea` or `TextComponent` value

|images: <<ImageType>>
|Represents details of images which were detected in the HtmlArea value, except images with `original` styles

|===

=== MacroDataConfigType

image:images/v-500.svg[Since version,opts=inline] Dynamic type which contains macro details. By default contains two fields: `disable` and `embed`, other fields will be added dynamically based on macro descriptors for provided `applicationKeys` during schema creation.
Given `applicationKeys` are expected to have the same order as in the site configs. It means that first macro descriptor that was matched will be used to process it.

|===
|Name (Arguments): Type | Description

|disable: <<Macro_system_disable>>
|Related content for `disable` macro

|embed: <<Macro_system_embed>>
|Related content for `embed` macro

|===

=== Macro_system_disable

|===
|Name (Arguments): Type | Description

|macroRef: String
|Reference to macro in the markup

|body: String
|Related content

|===

=== Macro_system_embed

|===
|Name (Arguments): Type | Description

|macroRef: String
|Reference to macro in the markup

|body: String
|Related content

|===

=== ImageType

image:images/v-500.svg[Since version,opts=inline] Represents image details in the HtmlArea markup. Example of usage <<image-processing#,here>>.

|===
|Name (Arguments): Type | Description

|image: <<Content>>
|Related content

|imageRef: String
|Reference to image in the markup

|style: <<ImageStyleType>>
|Related styles to image

|===

=== ImageStyleType

image:images/v-500.svg[Since version,opts=inline]

|===
|Name (Arguments): Type | Description

|name: String
|Style name

|aspectRatio: String
|The `aspect-ratio` value for server-side image processing

|filter: String
|The `filter` value for server-side image processing

|===

=== Permissions

==== Fields

|===
|Name(Arguments):Type | Description

|inheritsPermissions: Boolean
|Inherit permissions from parent content

|permissions: [<<AccessControlEntry>>]
|Permissions

|===

=== AccessControlEntry

==== Fields

|===
|Name(Arguments):Type | Description

|principal: <<PrincipalKey>>
|Principal key

|allow: [<<Permission>>]
|Allowed permissions

|deny: [<<Permission>>]
|Denied permissions

|===

=== PrincipalKey

==== Fields

|===
|Name(Arguments):Type | Description

|value: String
|Principal key value

|type: <<PrincipalType>>
|Principal type

|idProvider: String
|ID Provider name

|principalId: String
|Principal ID inside this user store

|===

=== ContentType

Representation of a content type definition

==== Fields

|===
|Name(Arguments):Type | Description

|name: String
|Content type name

|displayName: String
|Content type display name

|description: String
|Content type description

|superType: String
|Parent content type

|abstract: Boolean
|true if the content type is abstract

|final: Boolean
|true if the content type cannot be used as super type

|allowChildContent: Boolean
|true if content can be added under a content of this type

|contentDisplayNameScript: String
|

|icon: Icon
|

|form: [<<FormItem>>]
|Content type fields schema

|getInstances(
offset: Int
, first: Int
, query: String
, sort: String
): [<<Content>>]
|Util field returning the contents of this type

|getInstanceConnection(
after: String
, first: Int
, query: String
, sort: String
): <<ContentConnection>>
|Util field returning the contents of this type as a connection

|===

=== FormItem

==== Fields

|===
|Name(Arguments):Type | Description

|formItemType: <<FormItemType>>
|Form item type

|name: String
|Form item name

|label: String
|Form item label

|===

==== Direct Known Subtypes

Direct Known Subtypes: FormInput
, FormOptionSet
, FormLayout
, FormItemSet

=== ExtraData

==== Fields

|===
|Name(Arguments):Type | Description

|name: String
|Mixin name

|data: String
|Mixin value

|===

=== Component

==== Fields

|===
|Name(Arguments):Type | Description

|path: String
|Component path

|type: <<ComponentType>>
|Component type

|page: <<PageComponentData>>
|Data for page components

|layout: <<LayoutComponentData>>
|Data for layout components

|image: <<ImageComponentData>>
|Data for image components

|part: <<PartComponentData>>
|Data for part components

|text: <<TextComponentData>>
|Data for text components

|fragment: <<FragmentComponentData>>
|Data for fragment components

|===

=== PageComponentData

==== Fields

|===
|Name(Arguments):Type | Description

|descriptor: String
|Controller descriptor

|customized: Boolean
|True if the page is customized

|configAsJson: JSON
|Component config

|template: <<Content>>
|Related template content

|===

=== LayoutComponentData

==== Fields

|===
|Name(Arguments):Type | Description

|descriptor: String!
|Controller descriptor

|configAsJson: JSON
|Component config

|===

=== ImageComponentData

==== Fields

|===
|Name(Arguments):Type | Description

|id: ID!
|Image key

|caption: String
|Image caption

|image: media_Image
|Related image content

|===

=== PartComponentData

==== Fields

|===
|Name(Arguments):Type | Description

|descriptor: String!
|Controller descriptor

|configAsJson: JSON
|Component config

|===

=== TextComponentData

==== Fields

|===
|Name(Arguments):Type | Description

|value(processHtml: <<ProcessHtmlInput>>): <<HtmlEditorResult>>!
|Text value

|===

=== FragmentComponentData

==== Fields

|===
|Name(Arguments):Type | Description

|id: ID!
|Fragment key

|fragment: Content
|Related fragment content

|===

=== Attachment

==== Fields

|===
|Name(Arguments):Type | Description

|name: String
|Attachment name

|label: String
|Attachment label

|size: Int
|Attachment size

|mimeType: String
|Attachment mime type

|image:images/v-500.svg[Since version,opts=inline]  attachmentUrl: String
|Attachment URL

|===

=== PublishInfo

==== Fields

|===
|Name(Arguments):Type | Description

|from: String
|Scheduled publication start time

|to: String
|Scheduled publication end time

|first: String
|First publication time

|===

=== Icon

==== Fields

|===
|Name(Arguments):Type | Description

|mimeType: String
|Icon mime type

|modifiedTime: String
|Icon last modification time

|===

== ProcessHtmlInput

=== Fields

|===
|Name(Arguments):Type | Description

|type: <<UrlType>>
|URL type

|imageWidths: [Int]
|Generates image URLs for given widths which will be used in the `srcset` attribute of `img` tag.

|===

== Aggregation Input Types

=== AggregationInput

image:images/v-500.svg[Since version,opts=inline] Aggregations enable extracting statistical data from search results. Only one of the aggregation fields at a time can be specified.

==== Fields

|===
|Name(Arguments):Type | Description

|name: String!
|Aggregation name

|subAggregations: [<<AggregationInput>>]
|Sub aggregations

|terms: <<TermsAggregationInput>>
|Terms aggregation

|stats: <<StatsAggregationInput>>
|Stats aggregation

|range: <<RangeAggregationInput>>
|Range aggregation

|dateRange: <<DateRangeAggregationInput>>
|DateRange aggregation

|dateHistogram: <<DateHistogramAggregationInput>>
|DateHistogram aggregation

|getDistance: <<GeoDistanceAggregationInput>>
|GeoDistance aggregation

|===


=== TermsAggregationInput

==== Fields

|===
|Name(Arguments):Type | Description

|field: String!
|The property path

|order: String
|How to order the results, type and direction. Supports _term (Alphabetic ordering of bucket keys) and _count (Numeric ordering of bucket sizes) types. Defaults to _term ASC.

|size: Int
|Bucket size, ordered by the given orderType and orderDirection. Defaults to 10.

|===

=== StatsAggregationInput

==== Fields

|===
|Name(Arguments):Type | Description

|field: String!
|The property path

|===


=== RangeAggregationInput

==== Fields

|===
|Name(Arguments):Type | Description

|field: String!
|The property path.

|ranges: [ <<NumberRangeInput>> ]
|The range-buckets to create.

|===


=== NumberRangeInput

==== Fields

|===
|Name(Arguments):Type | Description

|from: Float
|From-value is included in bucket.

|to: Float
|To-value is excluded.

|===

=== DateRangeAggregationInput

==== Fields

|===
|Name(Arguments):Type | Description

|field: String!
|The property path.

|format: String
|Date/time format for buckets. Defaults to `yyyy-MM-dd’T’HH:mm:ss.SSSZ`.


|ranges: [ <<DateRangeInput>> ]
|The range-buckets to create.

|===


=== DateRangeInput

==== Fields

|===
|Name(Arguments):Type | Description

|from: String
|From-value is included in bucket.

|to: String
|To-value is excluded.

|===

=== DateHistogramAggregationInput

==== Fields

|===
|Name(Arguments):Type | Description

|field: String!
|The property path.

|interval: String
|The time-unit interval for buckets. Supported time-unit notations are `y`, `M`, `W`,`d`,`h`,`m`,`s`.


|format: String
|Date/time format for buckets. Defaults to `yyyy-MM-dd’T’HH:mm:ss.SSSZ`.


|minDocCount: Int
|Only include bucket in result if number of hits is equal or greater than `minDocCount`.

|===


=== GeoDistanceAggregationInput

==== Fields

|===
|Name(Arguments):Type | Description

|field: String!
|The property path.

|unit: String
|The measurement unit to use for the ranges. Allowed values are either full name or the abbreviation of the following: km (kilometers), m (meters), cm (centimeters), mm (millimeters), mi (miles), yd (yards), ft (feet) or nmi (nauticalmiles).

|origin: <<GeoPointInput>>
|The GeoPoint from which the distance is measured.

|ranges: [ <<NumberRangeInput>> ]
|The range-buckets to create.

|===

=== GeoPointInput

==== Fields

|===
|Name(Arguments):Type | Description

|lat: String!
|The latitude.

|lon: String!
|The longitude.

|===

== Filter Input Types

image:images/v-500.svg[Since version,opts=inline]

=== FilterInput

==== Fields

|===
|Name(Arguments):Type | Description

|boolean: <<BooleanFilterInput>>
|Boolean filter

|exists: <<ExistsFilterInput>>
|ExistsFilter

|notExists: <<NotExistsFilterInput>>
|NotExists filter

|hasValue: <<HasValueFilterInput>>
|HasValue filter

|ids: <<IdsFilterInput>>
|Ids filter

|===

=== BooleanFilterInput

==== Fields

|===
|Name(Arguments):Type | Description

|must: [<<FilterInput>>]
|All functions on the `must` array must evaluate to `true` for the filter to match

|mustNot: [<<FilterInput>>]
|All functions in the `mustNot` array must evaluate to `false` for the filter to match

|should: [<<FilterInput>>]
|At least one function in the `should` array must evaluate to `true for the filter to match

|===

=== ExistsFilterInput

==== Fields

|===
|Name(Arguments):Type | Description

|field: String!
|The property path

|===

=== NotExistsFilterInput

==== Fields

|===
|Name(Arguments):Type | Description

|field: String!
|The property path

|===


=== HasValueFilterInput

Only one value field can be specified.

==== Fields

|===
|Name(Arguments):Type | Description

|field: String!
|The property path

|stringValues: [String]
|Array of string values to find a match

|intValues: [Int]
|Array of integer values to find a match

|booleanValues: [Boolean]
|Array of boolean values to find a match

|floatValues: [Float]
|Array of float values to find a match

|===


=== IdsFilterInput

==== Fields

|===
|Name(Arguments):Type | Description

|values: [String]
|Array of ids to match

|===


== Enum Types

=== PrincipalType

Enum values: user
, group
, role

=== Permission

Enum values: READ
, CREATE
, MODIFY
, DELETE
, PUBLISH
, READ_PERMISSIONS
, WRITE_PERMISSIONS

=== FormItemType

Enum values: ItemSet
, Layout
, Input
, OptionSet

=== UrlType

Enum values: server
, absolute

=== ComponentType

Enum values: page
, layout
, image
, part
, text
, fragment
