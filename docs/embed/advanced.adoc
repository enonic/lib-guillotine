= Low level API

This section describes the various functions available for mounting and configuring the Guillotine library into your Enonic application.

== Functions

Starting from image:images/v-5.1.0.svg[Since version,opts=inline] Guillotine provides two new methods to simplify work with subscriptions and execution of a GraphQL query:

- `createWebSocketData(req)` - create data object for websocket from request. In site-less mode which is supported from version `5.6.0`, this function is not supported. The developer is responsible for implementing this functionality if needed.

[source,javascript]
----
webSocket: {
    data: guillotineLib.createWebSocketData(req),
    subProtocols: ['graphql-ws']
}
----

- `execute(params)` - This method allows you to execute a GraphQL query. To execute this method, it's enough to pass `query` and `variables`. In this case, a schema will be created for each branch of the site and can be further customised using the `schemaOptions` parameter. This schema will be automatically updated when the application is added to the site or when it is removed and re-deployed. Schemas created outside of this method have to be updated manually. In site less mode which is supported from version `5.6.0`, this function is not supported, therefore use `graphqlLib.execute` instead.

List of properties for `params` object:

|===
|Name | Description | Default value

|query:String
|GraphQL query. Property is required.
|

|variables:Object
|Variables for GraphQL query. Property is optional.
|

|siteId:String
|Site ID. Property is optional.
|ID of a current site.

|branch:String
|Branch. Property is optional.
|Branch from request.

|schema:SCHEMA
|GraphQL SCHEMA. Property is optional.
|

|schemaOptions:Object
|SchemaOptions object to customize schema. Property is optional.
|

|context:Object
|GraphQL context. Accessible in resolve function via `env.context`. Property is optional.
|
|===

List of properties for `schemaOptions` object:

|===
|Name | Description

|applications: String or Array.<String>
|Allowed application keys in addition to this site. Property is optional.

|allowPaths:String or Array.<String>
|Allowed content paths in addition to this site. Property is optional.

|subscriptionEventTypes:String or Array.<String>
|Specifies event type patterns to be listened by GraphQL Subscription. Property is optional.
|===

.Basic usage
[source,javascript]
----
const guillotineLib = require('/lib/guillotine');

exports.post = function (req) {
    let input = JSON.parse(req.body);

    let params = {
        query: input.query,
        variables: input.variables
    };

    return {
        contentType: 'application/json',
        body: guillotineLib.execute(params)
    };
};
----

.Usage with schema options
[source,javascript]
----
const guillotineLib = require('/lib/guillotine');
const contentLib = require('/lib/xp/content');
const contextLib = require('/lib/xp/context');
const portalLib = require('/lib/xp/portal');

exports.post = function (req) {
    let siteConfig = contextLib.run({
        branch: req.branch
    }, () => contentLib.getSiteConfig({
        key: portalLib.getSite()._id,
        applicationKey: 'com.enonic.app.guillotine'
    }));

    let input = JSON.parse(req.body);

    let params = {
        query: input.query,
        variables: input.variables,
        schemaOptions: {
            applications: siteConfig.applications,
            allowPaths: siteConfig.allowPaths,
            subscriptionEventTypes: siteConfig.subscriptionEventTypes
        }
    };

    return {
        contentType: 'application/json',
        body: guillotineLib.execute(params)
    };
};
----

.Customized schema
[source,javascript]
----
const guillotineLib = require('/lib/guillotine');

const SCHEMA = guillotineLib.createSchema();

exports.post = function (req) {
    let input = JSON.parse(req.body);

    let params = {
        query: input.query,
        variables: input.variables,
        schema: SCHEMA
    };

    return {
        contentType: 'application/json',
        body: guillotineLib.execute(params)
    };
};
----



== TODO

Cleanup?

.Setting contextual `branch`, `repositoryId` and `siteId` in the `data` object for WebSocket request:

[source,javascript]
----
const portalLib = require('/lib/xp/portal');

webSocket: {
    data: {
        branch: req.branch,
        repositoryId: req.repositoryId,
        siteId: portalLib.getSite()._id
    },
    subProtocols: ['graphql-ws']
}
----

or use the `guillotineLib.createWebSocketData(req)` method which is available starting from image:images/v-5.1.0.svg[Since verision,opts=inline].

Note: This function does not support in site-less (Global API) mode. In site-less mode provide `branch` and `repositoryId`. Also for GraphiQL IDE use `graphql-transport-ws` subProtocols instead of `graphql-ws`.

[source,javascript]
----
webSocket: {
    data: guillotineLib.createWebSocketData(req),
    subProtocols: ['graphql-ws']
}
----

Only `node.*` events are listened to by default. In order to configure which events should be listened to by an application or a site the `subscriptionEventTypes` option must be specified on schema creation, in this case default config will be overwritten.

[source,javascript]
----
var guillotineLib = require('/lib/guillotine');

var SCHEMA = guillotineLib.createSchema({
    subscriptionEventTypes: ['myapp.eventName', 'node.*']
});
----

To start handle a Websocket event XP provides the handler named `webSocketEvent`, which will be called for every Websocket event from client. More details about Websocket in XP https://developer.enonic.com/docs/xp/stable/framework/websocket[here].

Starting from image:images/v-500.svg[Since verision,opts=inline] Guillotine provides the `initWebSockets` function with default events handling. In site-less mode which is supported from version `5.6.0`, this function is not supported. The developer is responsible for implementing this functionality if needed.

[source,javascript]
----
exports.webSocketEvent = guillotineLib.initWebSockets(SCHEMA);
----

You might want to have custom subscriptions handling.
If default events filtering is not suitable for you, then you have to implement a custom `webSocketEvent` handler.


