= Guillotine library - Documentation

The guillotine library exposes the read-only part of the Enonic Content API, 
including access to the Enonic query language. 
Guillotine dynamically analyzes all available content types in applications and 
generates a GraphQL API specific to your site. 
This gives you direct, typed and documented access to all content within the site. 
Including the ability to follow references, child items and access media directly.


[NOTE] 
.GraphQL
==== 
GraphQL is a query language developed by Facebook. 
This technology allows Guillotine to provide a single and exhaustive API 
while allowing you to retrieve all the content information you need in one request without any superfluous information

http://graphql.org/learn[Learn more about GraphQL...]
====

== Usage

=== Step 1: Include the library

* Check that the Enonic repository is in the list of repositories

[source,gradle]
----
repositories {
    xp.enonicRepo()
}
----

* Add the following dependency (where `<version>` is the actual version to use):

[source,gradle]
----
dependencies {
    include 'com.enonic.lib:lib-guillotine:<version>'
}
----

=== Step 2: Create a GraphQL endpoint

* Schema creation - Call the guillotine function `createSchema`. 
By default, guillotine will generate a GraphQL schema containing the built-in content types and the content types defined by your application.
* Query execution - Handle POST requests, parse their body to retrieve the GraphQL query and variables and execute these query and 
variables against the schema using the graphql function `execute`.


==== Create a service using the default guillotine schema

* Create an Enonic XP service file /services/graphql/graphql.js` with the following content:

./services/graphql/graphql.js
[source,javascript]
----
var guillotineLib = require('/lib/guillotine'); <1>
var graphQlLib = require('/lib/graphql'); <1>

var schema = guillotineLib.createSchema(); <2>

exports.post = function (req) { <3>
    var body = JSON.parse(req.body); <4>
    var result = graphQlLib.execute(schema, body.query, body.variables); <5>
    return {
        contentType: 'application/json',
        body: result
    };
};
----
<1> Requires the Guillotine and GraphQL libraries. 
The GraphQL library is already included with Guillotine and does not need to be added to your Gradle file
<2> Creates the GraphQL schema the first time the service is called. 
<3> Handles POST requests
<4> Parses the JSON body to retrieve the GraphQL query and variables
<5> Executes the query and variables against the schema created

You now have a GraphQL endpoint.


=== Step 3: Use your GraphQL endpoint

==== GraphiQL

The easiest way to manually explore a GraphQL API and test GraphQL queries is to use GraphiQL

link:graphiql.html[Learn more about GraphiQL...]

==== Client

To use your GraphQL service, your client will send all its requests to the same service.
The service is expecting to receive a POST request with inside its body:

* A mandatory "query" String
* An optional "variables" Object

===== Example: Generate a service URL from a controller

[source,javascript]
----
var portalLib = require('/lib/xp/portal');
var graphqlServiceUrl = portalLib.serviceUrl({
    service: 'graphql'
});
----

===== Example: Fetch data from client javascript
[source,javascript]
----
const query = `query($path:ID!){
    guillotine {
        get(key:$path) {
            displayName
            type
        }
    }
}`;

const variables = {
    'path': '/mycontentpath'
};

fetch('{{graphqlServiceUrl}}', {
    method: 'POST',
    body: JSON.stringify({
        query: query,
        variables: variables
    }),
    credentials: 'same-origin'
})
    .then(response => response.json())
    .then(console.log);
----

== Guillotine GraphQL API

At the root of the default Guillotine schema is a type `Query` with a field `guillotine` of type `HeadlessCms`.
The `HeadlessCms` type gathers fields allowing to retrieve contents or related data.

=== Content

The type `Content` is an interface with multiple implementations generated from built-in content types but also from content types defined by your application.
All types implementing `Content` share the same fields at the exception of the field `data` defined for each implementation type.


=== Relations

Multiple relations are generated to allow to navigate between contents.
By default, each content has the following relations:

* parent: Link to the parent content 
* children: Link to the child contents
* site: Link to the nearest site content

Moreover, every ContentSelector, MediaUploader, AttachmentUploader or ImageSelector defined in your content type form will 
be converted to a link to the related content(s).

==== Example: Children 

Query example: Retrieve the display name of the current content and the display name of its direct children

----
{
  guillotine {
    get {
      displayName
      children {
        displayName
      }
    }
  }
}
----

==== Example: ContentSelector

Query example: Retrieve the blog posts. For each post, return its display name and the display name of the related author

----
{
  guillotine {
    query(contentTypes:"com.enonic.app.myapp:post") {
      displayName
      ... on com_enonic_app_myapp_Post {
        data {          
          author {
            displayName
          }
        }
      }
    }
  }
}
----

=== Image

Enonic XP can edit images at runtime. Guillotine uses this functionality by generating, on every image, a field "imageUrl" generating a URL pointing to the processed image.

==== Example: Scaled Image URL

Query example: Retrieve the image contents and generate absolute URLs to these images cropped to 800x200px

----
{
  guillotine {
    query(contentTypes:"media:image") {
      displayName
      ... on media_Image {
        imageUrl(scale:"block(800,200)",type:absolute)
      }
    }
  }
}
----

=== HTML

HTML fields are generated with a parameter "processHtml" allowing to replace abstract internal links by generated URLs. 

==== Example: Process HTML

Query example: Retrieve the Superhero blog posts. For each post, return its author display name, tags and processed content.

----
{
  guillotine {
    query(contentTypes:"com.enonic.app.myapp:post") {
      ... on com_enonic_app_myapp_Post {
        data {
          author {
            displayName
          }
          tags
          post(processHtml:{type:absolute})
        }
      }
    }
  }
}
----

=== Static GraphQL types

The documentation, linked below, lists and describes all static GraphQL types generated by Guillotine

link:static.html[Static GraphQL types documentation]

== Extend the schema

The default Guillotine schema provides fields based on the content type schemas.
But you might want to add/modify/delete fields (new retrieval methods, search in a separate database, virtual fields, ...).

The guillotine schema is entirely configurable. 
When creating a schema, you can define a listener for a type. 
This listener will be called before the type is created and given the possibility to modify the type creation parameters.

[NOTE] 
.GraphQL - Enonic XP Library
==== 
A library has been implemented to facilitate the creation of a GraphQL service on Enonic XP: `lib-graphql`.
Guillotine uses this library internally. The comprehension of the library is not necessary if you are using the default schema of Guillotine.
But if you decide to extend the schema with custom types, we recommend you to learn more about it by following the link below:

https://github.com/enonic/lib-graphql[Learn more about the GraphQL library...]
====

=== Example

In this example, we have types Author and Post generated. But we wish to apply the following modifications:

* Author should have a new field "fullName" that is the concatenation of firstName and lastName
* Author data field "email" should require admin rights to be retrieved.
* Author data field "birthDate" should not be accessible through the GraphQL API.
* Author should have a new field "posts" returning all the blog posts written by an author

./services/graphql/graphql.js
[source,javascript]
----
var contentLib = require('/lib/xp/content');
var guillotineLib = require('/lib/guillotine');
var graphQlLib = require('/lib/graphql');

var schema = guillotineLib.createSchema({
    creationCallbacks: {         
        'com_enonic_app_myapp_Author_Data': function(context, params){ <1>
            params.fields.fullName = {  <2>
                 type: graphQlLib.GraphQLString,
                 resolve: function (env) {
                     return env.source.firstName + ' ' + env.source.lastName;
                 }
             };
            params.fields.email.resolve = function (env) { <3>
                return authLib.hasRole('system.admin') ? env.source.email : null
            };            
            delete params.fields.birthDate;  <4>
        },  
        'com_enonic_app_myapp_Author': function(context, params){ <1>
            params.fields.posts = { <5>
                type: graphQlLib.list(graphQlLib.reference('com_enonic_app_myapp_Post')),
                resolve: function (env) {
                    return contentLib.query({
                        contentTypes: [app.name + ":Post"],
                        filters: {
                            hasValue: {
                                field: "data.author",
                                values: [env.source._id]
                            }
                        }
                    }).hits;
                }
            };
        }
    }
);

exports.post = function (req) {
    var body = JSON.parse(req.body);
    var result = graphQlLib.execute(schema, body.query, body.variables);
    return {
        contentType: 'application/json',
        body: result
    };
};
----
<1> Passes a callback that will be called before the creation of the specified GraphQL type. 
It receives the Guillotine context and the object type creation parameters.
<2> Adds a new string field "fullName" concatenating two other fields.
The resolution function will query contents of type post having the current author ID as field "data.author"
<3> Overwrites the resolution function of an existing field "email"
<4> Deletes an existing field "birthDate"
<5> Adds a new field "posts" returning a list of posts. 


These are only examples. You could also modify the type 'Query' and add an entire new API next to the Headless CMS API. 


== Integrate Headless CMS type to an existing schema

You may have an existing GraphQL schema and wish to integrate Guillotine types to this schema. 
In that case, use the functions `createContext` and `createHeadlessCmsType` instead of `createSchema`

==== Example

./services/graphql/graphql.js
[source,javascript]
----
var guillotineLib = require('/lib/guillotine');
var graphQlLib = require('/lib/graphql');

var schema = createSchema();

exports.post = function (req) {
    var body = JSON.parse(req.body);
    var result = graphQlLib.execute(schema, body.query, body.variables);
    return {
        contentType: 'application/json',
        body: result
    };
};

function createSchema() {
    var context = guillotineLib.createContext(); <1>
    return graphQlLib.createSchema({
        query: createRootQueryType(context),
        dictionary: context.dictionary <2>
    });
}

function createRootQueryType(context) {
    return graphQlLib.createObjectType({
        name: 'Query',
        fields: {
            guillotine: {
                type: guillotineLib.createHeadlessCmsType(context), <3>
                resolve: function () {
                    return {};
                }
            }
        }
    });
}
----
<1> Creates the context necessary to create Guillotine types.
<2> Passes the dictionary to the schema creation. The use of a dictionary is necessary to define interface implementations.
<3> Creates the Guillotine Headless CMS type




