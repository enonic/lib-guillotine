= Guillotine library - Documentation

Guillotine library exposes the read-only part of the Enonic Content API, 
including access to the Enonic query language. 
Guillotine dynamically analyzes all available content types in applications and 
generates a GraphQL API specific to your site. 
This gives you direct, typed and documented access to all content within the site. 
Including the ability to follow references, child items and access media directly.

== GraphQL

GraphQL is a query language developed by Facebook. 
This technology allows Guillotine to provide a single and exhaustive API 
while allowing you to retrieve all the content information you need in one request without any superfluous information

http://graphql.org/learn[Learn more about GraphQL...]

== GraphQL - Enonic XP Library

A library has been implemented to facilitate the creation of a GraphQL service on Enonic XP: `lib-graphql`.
Guillotine uses this library internally. The comprehension of the library is not necessary if you are using the default schema of Guillotine.

But if you decide to extend the schema with custom types, we recommend to learn more about it by following the link below:

https://github.com/enonic/lib-graphql[Learn more about the GraphQL library...]

== Usage

=== Step1: Include the library

To include the library in your Enonic XP application, 
you will first need to add the Enonic repository to the repository list:

[source,gradle]
----
repositories {
    maven {
        url 'http://repo.enonic.com/public'
    }
}
----

Add the following dependency (where `<version>` is the actual version to use):

[source,gradle]
----
dependencies {
    include 'com.enonic.lib:lib-guillotine:<version>'
}
----

=== Step2: Schema generation

The library handles two cases:

* You want to generate the entire GraphQL schema with possibilities to modify and extend it.
** Use the function `createSchema`
** See examples 1 and 2 below
* You have an existing GraphQL schema and you wish to integrate Guillotine types to this schema.
** Use the functions `createContext` and `createHeadlessCms`
** See example 3

==== Example 1: Create a service using the default guillotine schema

Create an Enonic XP service file (example: /services/graphql/graphql.js) with the following code:

./services/graphql/graphql.js
[source,javascript]
----
var guillotineLib = require('/lib/guillotine'); <1>
var graphQlLib = require('/lib/graphql'); <1>

var schema = guillotineLib.createSchema(); <2>

exports.post = function (req) {
    var body = JSON.parse(req.body);
    var result = graphQlLib.execute(schema, body.query, body.variables); <3>
    return {
        contentType: 'application/json',
        body: result
    };
};
----
<1> Requires the Guillotine and GraphQL libraries. 
The GraphQL library is already included with Guillotine and does not need to be added to your Gradle file
<2> Creates the GraphQL schema the first time the service is called. 
<3> On a POST request, executes the query and variables received in the body of the request

You now have a GraphQL endpoint. See GraphiQL below to try out your GraphQL endpoint


==== Example 2: Create a service using an extended guillotine schema

The default Guillotine schema provides fields based on the content type schemas.
But you might want to add new retrieval methods, search in a separate database, add virtual fields, ...
The guillotine is entirely configurable by letting you modify the parameters of each type before they get created.

In this example using blog posts and authors, we want the following:

* The author should have a new field "fullName" that is the concatenation of firstName and lastName
* There should be a relationship "posts" returning all the blog posts written by an author
* The existing author data field "email" should require admin rights to be retrieved.
* The existing author data field "birthDate" should not be accessible through the GraphQL API.

./services/graphql/graphql.js
[source,javascript]
----
var contentLib = require('/lib/xp/content');
var guillotineLib = require('/lib/guillotine');
var graphQlLib = require('/lib/graphql');

var schema = guillotineLib.createSchema({
    creationCallbacks: {
        'com_enonic_app_myapp_Post': function(context, params){ <1>
            params.fields.fullName = {  <2>
                 type: graphQlLib.GraphQLString,
                 resolve: function (env) {
                     return env.source.firstName + ' ' + env.source.lastName;
                 }
             };
        },        
        'com_enonic_app_myapp_Author': function(context, params){ <1>
            params.fields.posts = { <3>
                type: graphQlLib.list(graphQlLib.reference('com_enonic_app_myapp_Post')),
                resolve: function (env) {
                    return contentLib.query({
                        contentTypes: [app.name + ":Post"],
                        filters: {
                            hasValue: {
                                field: "data.author",
                                values: [ env.source._id]
                            }
                        }
                    }).hits;
                }
            };
        },     
        'com_enonic_app_myapp_Author_Data': function(context, params){ <1>
            params.fields.email.resolve = function (env) { <4>
                return authLib.hasRole('system.admin') ? env.source.email : null
            };            
            delete params.fields.birthDate;  <5>
        }
    }
);

exports.post = function (req) {
    var body = JSON.parse(req.body);
    var result = graphQlLib.execute(schema, body.query, body.variables);
    return {
        contentType: 'application/json',
        body: result
    };
};
----

<1> Pass a callback that will be called before the creation of the specified GraphQL type. 
It receives the Guillotine context and the object type creation parameters.
<2> Adds a new string field "fullName" concatenating two other fields.
<3> Adds a new field "posts" returning a list of posts. 
The resolution function will query contents of type post having the current author ID as field "data.author"
<4> Overwrites the resolution of an existing field "email"
<5> Deletes an existing field "birthDate"


These are only examples. You could also modify the type 'Query' and add an entire new API next to the Headless CMS API. 


==== Example 3: Integrate the Headless CMS to your existing schema

TODO


== GraphiQL

The easiest way to manually explore a GraphQL API and test GraphQL queries is to use GraphiQL

link:graphiql.html[Learn more about GraphiQL...]

